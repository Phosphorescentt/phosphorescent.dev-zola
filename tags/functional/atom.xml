<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title> - functional</title>
    <link rel="self" type="application/atom+xml" href="https://phosphorescent.dev/tags/functional/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://phosphorescent.dev"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-04-06T00:00:00+00:00</updated>
    <id>https://phosphorescent.dev/tags/functional/atom.xml</id>
    <entry xml:lang="en">
        <title>Functional programming streamlines additional behaviour</title>
        <published>2025-03-27T00:00:00+00:00</published>
        <updated>2025-04-06T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://phosphorescent.dev/pages/functional-vs-oop/"/>
        <id>https://phosphorescent.dev/pages/functional-vs-oop/</id>
        
        <content type="html" xml:base="https://phosphorescent.dev/pages/functional-vs-oop/">&lt;p&gt;Below is a quote I found from an &lt;a href=&quot;https:&#x2F;&#x2F;chelseatroy.com&#x2F;2021&#x2F;05&#x2F;01&#x2F;building-an-interpreter-the-visitor-pattern&#x2F;&quot;&gt;article on the visitor
pattern&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bob explains that we have two ways to orient our code. We could do it with objects, by
having each of these expressions represented as classes handling all their own
operations, or we could do it with functions that switch their behavior based on which
type of expression they have been passed. The former (object) pattern makes it less
work to add a new expression class and more work to add a new behavior, since we have
to crack open every existing class to do it. The latter (functional) pattern makes it
less work to add a new behavior, since we just need to write a new function without
changing existing code. Adding a new expression, though, means cracking open all the
existing functions and adding a case to each.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;This is a summary of functional vs object oriented approaches that I haven&#x27;t seen
before. This perspective helps me explain &lt;em&gt;why&lt;&#x2F;em&gt; I prefer functional approaches to
solving software problems as opposed to object oriented ones: my (admittedly limited)
professional experience to date has shown me that underlying data models don&#x27;t change
that much, but the behaviour often does.&lt;&#x2F;p&gt;
&lt;p&gt;With this in mind, it seems clear to me that we should adopt some of functional
approaches to solving problems as it gives us more agility when the product requirements
aren&#x27;t very well defined, but the shape of the data is. Of course, if you know that your
behaviour is unlikely to change very much, but your model space isn&#x27;t well understood
then perhaps an object oriented approach will work better.&lt;&#x2F;p&gt;
&lt;p&gt;This is all personal opinion from someone who has been data engineering for most of
their career so take this interpretation with a pinch of salt.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
